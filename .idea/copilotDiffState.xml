<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/common/common-data/src/main/java/com/em/common/dto/user/AddressCreateRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/common/common-data/src/main/java/com/em/common/dto/user/AddressCreateRequest.java" />
              <option name="updatedContent" value="package com.em.common.dto.user;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class AddressCreateRequest {&#10;&#10;    private String street;&#10;    private String city;&#10;    private String state;&#10;    private String zipCode;&#10;    private String country;&#10;    private boolean isDefault;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/common/common-data/src/main/java/com/em/common/dto/user/AddressDto.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/common/common-data/src/main/java/com/em/common/dto/user/AddressDto.java" />
              <option name="updatedContent" value="package com.em.common.dto.user;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class AddressDto {&#10;&#10;    private Long id;&#10;    private String street;&#10;    private String city;&#10;    private String state;&#10;    private String zipCode;&#10;    private String country;&#10;    private boolean isDefault;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/common/common-data/src/main/java/com/em/common/dto/user/AddressUpdateRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/common/common-data/src/main/java/com/em/common/dto/user/AddressUpdateRequest.java" />
              <option name="updatedContent" value="package com.em.common.dto.user;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class AddressUpdateRequest {&#10;&#10;    private String street;&#10;    private String city;&#10;    private String state;&#10;    private String zipCode;&#10;    private String country;&#10;    private boolean isDefault;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/common/common-data/src/main/java/com/em/common/dto/user/UserProfileResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/common/common-data/src/main/java/com/em/common/dto/user/UserProfileResponse.java" />
              <option name="originalContent" value="}&#10;    private LocalDateTime updatedAt;&#10;    private LocalDateTime createdAt;&#10;    private String avatarUrl;&#10;    private LocalDate dateOfBirth;&#10;    private String gender;&#10;    private String phoneNumber;&#10;    private String lastName;&#10;    private String firstName;&#10;    private String id;&#10;&#10;public class UserProfileResponse {&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;@Builder&#10;@Data&#10;&#10;import java.time.LocalDateTime;&#10;import java.time.LocalDate;&#10;&#10;import lombok.NoArgsConstructor;&#10;import lombok.Data;&#10;import lombok.Builder;&#10;import lombok.AllArgsConstructor;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.em.common.dto.user;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class UserProfileResponse {&#10;&#10;    private String id;&#10;    private String firstName;&#10;    private String lastName;&#10;    private String phoneNumber;&#10;    private String gender;&#10;    private LocalDate dateOfBirth;&#10;    private String avatarUrl;&#10;    private LocalDateTime createdAt;&#10;    private LocalDateTime updatedAt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/common/common-data/src/main/java/com/em/common/dto/user/UserProfileUpdateRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/common/common-data/src/main/java/com/em/common/dto/user/UserProfileUpdateRequest.java" />
              <option name="updatedContent" value="package com.em.common.dto.user;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class UserProfileUpdateRequest {&#10;&#10;    private String firstName;&#10;    private String lastName;&#10;    private String phoneNumber;&#10;    private String gender;&#10;    private LocalDate dateOfBirth;&#10;    private String avatarUrl;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/web-client/src/components/chat/ChatSidebar.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/web-client/src/components/chat/ChatSidebar.tsx" />
              <option name="originalContent" value="import {MessageSquarePlus, Search} from 'lucide-react';&#10;import type {ChatListItem} from './types';&#10;import {motion} from 'framer-motion';&#10;&#10;interface Props {&#10;    items: ChatListItem[];&#10;    onSelect: (id: string) =&gt; void;&#10;    selectedId?: string | null;&#10;}&#10;&#10;export function ChatSidebar({items, onSelect, selectedId}: Props) {&#10;    return (&#10;        &lt;div&#10;            className=&quot;w-80 bg-white dark:bg-neutral-900 rounded-2xl shadow-md border border-gray-200 dark:border-neutral-800 flex flex-col overflow-hidden&quot;&gt;&#10;            {/* Header */}&#10;            &lt;div&#10;                className=&quot;px-4 pt-4 pb-3 bg-white/70 dark:bg-neutral-900/70 backdrop-blur border-b border-gray-200 dark:border-neutral-800&quot;&gt;&#10;                &lt;div className=&quot;flex items-center justify-between mb-3&quot;&gt;&#10;                    &lt;h2 className=&quot;text-base font-semibold text-gray-900 dark:text-gray-100&quot;&gt;Messages&lt;/h2&gt;&#10;                    &lt;button&#10;                        className=&quot;p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-neutral-800 text-gray-500&quot;&#10;                        title=&quot;New chat&quot;&#10;                    &gt;&#10;                        &lt;MessageSquarePlus size={18}/&gt;&#10;                    &lt;/button&gt;&#10;                &lt;/div&gt;&#10;                &lt;div className=&quot;relative&quot;&gt;&#10;                    &lt;Search size={18} className=&quot;absolute left-3 top-1/2 -translate-y-1/2 text-gray-400&quot;/&gt;&#10;                    &lt;input&#10;                        placeholder=&quot;Search or start new chat&quot;&#10;                        className=&quot;w-full h-10 pl-10 pr-3 rounded-full bg-gray-100 dark:bg-neutral-800 text-sm focus:outline-none focus:ring-2 focus:ring-[#0084ff]/40&quot;&#10;                    /&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;            {/* List */}&#10;            &lt;div className=&quot;flex-1 overflow-y-auto p-2 space-y-1&quot;&gt;&#10;                {items.map((c) =&gt; (&#10;                    &lt;motion.button&#10;                        key={c.id}&#10;                        onClick={() =&gt; onSelect(c.id)}&#10;                        initial={{opacity: 0, y: 6}}&#10;                        animate={{opacity: 1, y: 0}}&#10;                        className={`w-full flex items-center gap-3 p-3 rounded-xl transition text-left border ${&#10;                            selectedId === c.id&#10;                                ? 'bg-gray-50 dark:bg-neutral-800 border-gray-200 dark:border-neutral-700 shadow-sm'&#10;                                : 'hover:bg-gray-50 dark:hover:bg-neutral-800 border-transparent'&#10;                        }`}&#10;                    &gt;&#10;                        &lt;div className=&quot;relative&quot;&gt;&#10;                            &lt;div&#10;                                className=&quot;w-11 h-11 rounded-full bg-gradient-to-br from-purple-400 to-purple-600 flex items-center justify-center text-base ring-2 ring-white dark:ring-neutral-900&quot;&gt;&#10;                                {c.avatar ?? ''}&#10;                            &lt;/div&gt;&#10;                            &lt;span&#10;                                className=&quot;absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-emerald-500 rounded-full ring-2 ring-white dark:ring-neutral-900&quot;/&gt;&#10;                        &lt;/div&gt;&#10;                        &lt;div className=&quot;flex-1 min-w-0&quot;&gt;&#10;                            &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;                                &lt;p className=&quot;text-sm font-semibold text-gray-900 dark:text-gray-100 truncate&quot;&gt;{c.name}&lt;/p&gt;&#10;                                &lt;span className=&quot;text-[10px] text-gray-500&quot;&gt;{c.lastMessageTime}&lt;/span&gt;&#10;                            &lt;/div&gt;&#10;                            &lt;p className=&quot;text-xs text-gray-500 truncate&quot;&gt;{c.lastMessage}&lt;/p&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/motion.button&gt;&#10;                ))}&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default ChatSidebar;&#10;" />
              <option name="updatedContent" value="import {Search, MessageSquarePlus} from 'lucide-react';&#10;import type {ChatListItem} from './types';&#10;import {motion} from 'framer-motion';&#10;import {Input} from '../ui/input';&#10;import {Button} from '../ui/button';&#10;&#10;interface Props {&#10;    items: ChatListItem[];&#10;    onSelect: (id: string) =&gt; void;&#10;    selectedId?: string | null;&#10;}&#10;&#10;export function ChatSidebar({items, onSelect, selectedId}: Props) {&#10;    return (&#10;        &lt;div className=&quot;w-80 bg-white dark:bg-neutral-900 rounded-2xl shadow-md border border-gray-200 dark:border-neutral-800 flex flex-col overflow-hidden&quot;&gt;&#10;            {/* Header */}&#10;            &lt;div className=&quot;px-4 pt-4 pb-3 bg-white/70 dark:bg-neutral-900/70 backdrop-blur border-b border-gray-200 dark:border-neutral-800&quot;&gt;&#10;                &lt;div className=&quot;flex items-center justify-between mb-3&quot;&gt;&#10;                    &lt;h2 className=&quot;text-base font-semibold text-gray-900 dark:text-gray-100&quot;&gt;Messages&lt;/h2&gt;&#10;                    &lt;Button variant=&quot;ghost&quot; size=&quot;icon&quot; title=&quot;New chat&quot;&gt;&#10;                        &lt;MessageSquarePlus size={18}/&gt;&#10;                    &lt;/Button&gt;&#10;                &lt;/div&gt;&#10;                &lt;div className=&quot;relative&quot;&gt;&#10;                    &lt;Search size={18} className=&quot;absolute left-3 top-1/2 -translate-y-1/2 text-gray-400&quot;/&gt;&#10;                    &lt;Input placeholder=&quot;Search or start new chat&quot; className=&quot;pl-10 rounded-full bg-gray-100 dark:bg-neutral-800 border-none focus:ring-[#0084ff]/40&quot;/&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;            {/* List */}&#10;            &lt;div className=&quot;flex-1 overflow-y-auto p-2 space-y-1&quot;&gt;&#10;                {items.map((c) =&gt; (&#10;                    &lt;motion.button&#10;                        key={c.id}&#10;                        onClick={() =&gt; onSelect(c.id)}&#10;                        initial={{opacity: 0, y: 6}}&#10;                        animate={{opacity: 1, y: 0}}&#10;                        className={`w-full flex items-center gap-3 p-3 rounded-xl transition text-left border ${&#10;                            selectedId === c.id&#10;                                ? 'bg-gray-50 dark:bg-neutral-800 border-gray-200 dark:border-neutral-700 shadow-sm'&#10;                                : 'hover:bg-gray-50 dark:hover:bg-neutral-800 border-transparent'&#10;                        }`}&#10;                    &gt;&#10;                        &lt;div className=&quot;relative&quot;&gt;&#10;                            &lt;div className=&quot;w-11 h-11 rounded-full bg-gradient-to-br from-purple-400 to-purple-600 flex items-center justify-center text-base ring-2 ring-white dark:ring-neutral-900&quot;&gt;&#10;                                {c.avatar ?? ''}&#10;                            &lt;/div&gt;&#10;                            &lt;span className=&quot;absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-emerald-500 rounded-full ring-2 ring-white dark:ring-neutral-900&quot;/&gt;&#10;                        &lt;/div&gt;&#10;                        &lt;div className=&quot;flex-1 min-w-0&quot;&gt;&#10;                            &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;                                &lt;p className=&quot;text-sm font-semibold text-gray-900 dark:text-gray-100 truncate&quot;&gt;{c.name}&lt;/p&gt;&#10;                                &lt;span className=&quot;text-[10px] text-gray-500&quot;&gt;{c.lastMessageTime}&lt;/span&gt;&#10;                            &lt;/div&gt;&#10;                            &lt;p className=&quot;text-xs text-gray-500 truncate&quot;&gt;{c.lastMessage}&lt;/p&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/motion.button&gt;&#10;                ))}&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default ChatSidebar;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/web-client/src/components/chat/MessageInput.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/web-client/src/components/chat/MessageInput.tsx" />
              <option name="originalContent" value="import {Paperclip, Send, Smile} from 'lucide-react';&#10;import {useState} from 'react';&#10;&#10;interface Props {&#10;    onSend: (text: string) =&gt; void;&#10;    accent?: string;&#10;}&#10;&#10;export function MessageInput({onSend, accent = '#0084ff'}: Props) {&#10;    const [text, setText] = useState('');&#10;&#10;    const handleSend = () =&gt; {&#10;        const t = text.trim();&#10;        if (!t) return;&#10;        onSend(t);&#10;        setText('');&#10;    };&#10;&#10;    return (&#10;        &lt;div&#10;            className=&quot;h-16 border-t border-gray-200 dark:border-gray-700 px-4 flex items-center gap-2 bg-white/90 dark:bg-neutral-900/90 backdrop-blur rounded-b-2xl&quot;&gt;&#10;            &lt;button className=&quot;p-2 hover:bg-gray-100 dark:hover:bg-neutral-800 rounded-full&quot; aria-label=&quot;Emoji&quot;&gt;&#10;                &lt;Smile size={20} className=&quot;text-gray-500&quot;/&gt;&#10;            &lt;/button&gt;&#10;            &lt;button className=&quot;p-2 hover:bg-gray-100 dark:hover:bg-neutral-800 rounded-full&quot; aria-label=&quot;Attach&quot;&gt;&#10;                &lt;Paperclip size={20} className=&quot;text-gray-500&quot;/&gt;&#10;            &lt;/button&gt;&#10;            &lt;input&#10;                className=&quot;flex-1 h-10 px-4 rounded-full bg-gray-100 dark:bg-neutral-800 text-sm focus:outline-none focus:ring-2 focus:ring-[#0084ff]/40&quot;&#10;                placeholder=&quot;Type a message&quot;&#10;                value={text}&#10;                onChange={(e) =&gt; setText(e.target.value)}&#10;                onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleSend()}&#10;            /&gt;&#10;            &lt;button&#10;                onClick={handleSend}&#10;                className=&quot;w-10 h-10 rounded-full text-white flex items-center justify-center shadow-sm hover:shadow transition&quot;&#10;                style={{background: accent}}&#10;                aria-label=&quot;Send&quot;&#10;            &gt;&#10;                &lt;Send size={18}/&gt;&#10;            &lt;/button&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default MessageInput;&#10;" />
              <option name="updatedContent" value="import {Smile, Send, Paperclip} from 'lucide-react';&#10;import {useRef, useState} from 'react';&#10;&#10;interface Props {&#10;    onSend: (text: string) =&gt; void;&#10;    accent?: string;&#10;}&#10;&#10;export function MessageInput({onSend, accent = '#0084ff'}: Props) {&#10;    const [text, setText] = useState('');&#10;    const [open, setOpen] = useState(false);&#10;    const panelRef = useRef&lt;HTMLDivElement | null&gt;(null);&#10;&#10;    const handleSend = () =&gt; {&#10;        const t = text.trim();&#10;        if (!t) return;&#10;        onSend(t);&#10;        setText('');&#10;        setOpen(false);&#10;    };&#10;&#10;    const emojis = ['','','','','','','','','❤️',''];&#10;&#10;    return (&#10;        &lt;div&#10;            className=&quot;relative h-16 border-t border-gray-200 dark:border-gray-700 px-4 flex items-center gap-2 bg-white/90 dark:bg-neutral-900/90 backdrop-blur rounded-b-2xl&quot;&gt;&#10;            &lt;div className=&quot;relative&quot;&gt;&#10;                &lt;button className=&quot;p-2 hover:bg-gray-100 dark:hover:bg-neutral-800 rounded-full&quot; aria-label=&quot;Emoji&quot; onClick={() =&gt; setOpen(v=&gt;!v)}&gt;&#10;                    &lt;Smile size={20} className=&quot;text-gray-500&quot;/&gt;&#10;                &lt;/button&gt;&#10;                {open &amp;&amp; (&#10;                    &lt;div ref={panelRef} className=&quot;absolute bottom-12 left-0 z-10 w-56 bg-white dark:bg-neutral-900 border border-gray-200 dark:border-neutral-800 rounded-xl shadow-lg p-2 grid grid-cols-6 gap-2&quot;&gt;&#10;                        {emojis.map((e) =&gt; (&#10;                            &lt;button key={e} className=&quot;text-xl hover:bg-gray-100 dark:hover:bg-neutral-800 rounded&quot; onClick={() =&gt; setText((t)=&gt; t + e)}&gt;&#10;                                {e}&#10;                            &lt;/button&gt;&#10;                        ))}&#10;                    &lt;/div&gt;&#10;                )}&#10;            &lt;/div&gt;&#10;            &lt;button className=&quot;p-2 hover:bg-gray-100 dark:hover:bg-neutral-800 rounded-full&quot; aria-label=&quot;Attach&quot;&gt;&#10;                &lt;Paperclip size={20} className=&quot;text-gray-500&quot;/&gt;&#10;            &lt;/button&gt;&#10;            &lt;input&#10;                className=&quot;flex-1 h-10 px-4 rounded-full bg-gray-100 dark:bg-neutral-800 text-sm focus:outline-none focus:ring-2 focus:ring-[#0084ff]/40&quot;&#10;                placeholder=&quot;Type a message&quot;&#10;                value={text}&#10;                onChange={(e) =&gt; setText(e.target.value)}&#10;                onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleSend()}&#10;            /&gt;&#10;            &lt;button&#10;                onClick={handleSend}&#10;                className=&quot;w-10 h-10 rounded-full text-white flex items-center justify-center shadow-sm hover:shadow transition&quot;&#10;                style={{background: accent}}&#10;                aria-label=&quot;Send&quot;&#10;            &gt;&#10;                &lt;Send size={18}/&gt;&#10;            &lt;/button&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default MessageInput;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/web-client/src/components/ui/button.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/web-client/src/components/ui/button.tsx" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { cn } from '../../lib/utils';&#10;&#10;export interface ButtonProps extends React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {&#10;  variant?: 'default' | 'ghost' | 'outline';&#10;  size?: 'sm' | 'md' | 'icon';&#10;}&#10;&#10;export const Button = React.forwardRef&lt;HTMLButtonElement, ButtonProps&gt;(&#10;  ({ className, variant = 'default', size = 'md', ...props }, ref) =&gt; {&#10;    const base = 'inline-flex items-center justify-center font-medium rounded-lg transition focus:outline-none focus-visible:ring-2 focus-visible:ring-blue-400 disabled:opacity-50 disabled:pointer-events-none';&#10;    const variants = {&#10;      default: 'bg-blue-500 text-white hover:bg-blue-600',&#10;      ghost: 'bg-transparent hover:bg-gray-100 text-gray-700',&#10;      outline: 'border border-gray-300 hover:bg-gray-50 text-gray-700',&#10;    } as const;&#10;    const sizes = {&#10;      sm: 'h-8 px-3 text-sm',&#10;      md: 'h-10 px-4 text-sm',&#10;      icon: 'h-10 w-10',&#10;    } as const;&#10;&#10;    return (&#10;      &lt;button ref={ref} className={cn(base, variants[variant], sizes[size], className)} {...props} /&gt;&#10;    );&#10;  }&#10;);&#10;Button.displayName = 'Button';&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/web-client/src/components/ui/input.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/web-client/src/components/ui/input.tsx" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { cn } from '../../lib/utils';&#10;&#10;export interface InputProps extends React.InputHTMLAttributes&lt;HTMLInputElement&gt; {}&#10;&#10;export const Input = React.forwardRef&lt;HTMLInputElement, InputProps&gt;(({ className, ...props }, ref) =&gt; {&#10;  return (&#10;    &lt;input&#10;      ref={ref}&#10;      className={cn('flex h-10 w-full rounded-lg border border-gray-300 bg-white px-3 text-sm shadow-sm placeholder:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-300', className)}&#10;      {...props}&#10;    /&gt;&#10;  );&#10;});&#10;Input.displayName = 'Input';&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/web-client/src/lib/utils.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/web-client/src/lib/utils.ts" />
              <option name="updatedContent" value="export function cn(...classes: Array&lt;string | false | null | undefined&gt;) {&#10;  return classes.filter(Boolean).join(' ');&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/product-service/src/main/java/com/em/productservice/Repository/ProductRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/product-service/src/main/java/com/em/productservice/Repository/ProductRepository.java" />
              <option name="originalContent" value="package com.em.productservice.Repository;&#10;&#10;import com.em.productservice.Model.Product;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface ProductRepository extends MongoRepository&lt;Product, String&gt; {&#10;&#10;    Optional&lt;Product&gt; findByName(String name);&#10;&#10;    boolean existsByName(String name);&#10;&#10;    Optional&lt;Product&gt; findByNameIgnoreCase(String name);&#10;&#10;    boolean existsByNameIgnoreCase(String name);&#10;&#10;    List&lt;Product&gt; findAllByIdIn(List&lt;String&gt; ids);&#10;&#10;    // 1. Featured&#10;    List&lt;Product&gt; findByIsFeaturedTrue(Pageable pageable);&#10;&#10;    // 2. New Arrivals&#10;    List&lt;Product&gt; findByIsAvailableTrue(Pageable pageable);&#10;&#10;    // 3. Most Liked&#10;    List&lt;Product&gt; findByIsAvailableTrueOrderByAverageRatingDesc(Pageable pageable);&#10;&#10;    // 4. Basic paginated find-all for shop&#10;    Page&lt;Product&gt; findAll(Pageable pageable);&#10;}&#10;" />
              <option name="updatedContent" value="package com.em.productservice.Repository;&#10;&#10;import com.em.productservice.Model.Product;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.mongodb.repository.MongoRepository;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface ProductRepository extends MongoRepository&lt;Product, String&gt; {&#10;&#10;    Optional&lt;Product&gt; findByName(String name);&#10;&#10;    boolean existsByName(String name);&#10;&#10;    Optional&lt;Product&gt; findByNameIgnoreCase(String name);&#10;&#10;    boolean existsByNameIgnoreCase(String name);&#10;&#10;    List&lt;Product&gt; findAllByIdIn(List&lt;String&gt; ids);&#10;&#10;    // 1. Featured&#10;    List&lt;Product&gt; findByIsFeaturedTrue(Pageable pageable);&#10;&#10;    // 2. New Arrivals&#10;    List&lt;Product&gt; findByIsAvailableTrue(Pageable pageable);&#10;&#10;    // 3. Most Liked&#10;    List&lt;Product&gt; findByIsAvailableTrueOrderByAverageRatingDesc(Pageable pageable);&#10;&#10;    // 4. Basic paginated find-all for shop&#10;    Page&lt;Product&gt; findAll(Pageable pageable);&#10;&#10;    // 5. Filtered by category slug and price range&#10;    Page&lt;Product&gt; findByPrimaryCategoryNameIgnoreCaseAndPriceBetween(String primaryCategoryName,&#10;                                                                     double minPrice,&#10;                                                                     double maxPrice,&#10;                                                                     Pageable pageable);&#10;&#10;    Page&lt;Product&gt; findByPriceBetween(double minPrice, double maxPrice, Pageable pageable);&#10;&#10;    Page&lt;Product&gt; findByPrimaryCategoryNameIgnoreCase(String primaryCategoryName, Pageable pageable);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/product-service/src/main/java/com/em/productservice/Service/ProductService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/product-service/src/main/java/com/em/productservice/Service/ProductService.java" />
              <option name="originalContent" value="package com.em.productservice.Service;&#10;&#10;import com.em.commonevent.ProductCreatedEvent;&#10;import com.em.productservice.Model.Category;&#10;import com.em.productservice.Model.Product;&#10;import com.em.productservice.Repository.CategoryRepository;&#10;import com.em.productservice.Repository.ProductRepository;&#10;import com.em.productservice.dto.request.ProductRequest;&#10;import com.em.common.dto.product.CategoryResponse;&#10;import com.em.productservice.dto.response.HomePageResponse;&#10;import com.em.common.dto.product.ProductResponse;&#10;import com.em.productservice.events.EventPublisherService;&#10;import com.em.productservice.exception.CategoryNotFoundException;&#10;import com.em.productservice.exception.DuplicateProductException;&#10;import com.em.productservice.exception.InvalidProductDataException;&#10;import com.em.productservice.exception.ProductNotFoundException;&#10;import lombok.AllArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.Arrays;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.concurrent.CompletableFuture;&#10;&#10;@Service&#10;@AllArgsConstructor&#10;@Slf4j&#10;public class ProductService {&#10;&#10;    private final ProductRepository productRepository;&#10;    private final CategoryRepository categoryRepository;&#10;    private final EventPublisherService eventPublisher;&#10;&#10;    public List&lt;ProductResponse&gt; getAllProducts() {&#10;        log.info(&quot;Fetching all products from database...&quot;);&#10;        List&lt;Product&gt; products = productRepository.findAll();&#10;        log.info(&quot;Found {} products in database&quot;, products.size());&#10;&#10;        List&lt;ProductResponse&gt; productResponses = products.stream()&#10;                .map(this::mapToProductResponse)&#10;                .toList();&#10;        log.info(&quot;Mapped {} products to response DTOs&quot;, productResponses.size());&#10;&#10;        return productResponses;&#10;    }&#10;&#10;    public ProductResponse getProductById(String id) {&#10;        log.info(&quot;Fetching product with ID: {}&quot;, id);&#10;        Product product = productRepository.findById(id)&#10;                .orElseThrow(() -&gt; new ProductNotFoundException(&quot;Product with ID &quot; + id + &quot; not found&quot;));&#10;&#10;        log.info(&quot;Found product: {}&quot;, product.getName());&#10;        return mapToProductResponse(product);&#10;    }&#10;&#10;    private ProductResponse mapToProductResponse(Product product) {&#10;        // Convert Category objects to common CategoryResponse DTOs&#10;        List&lt;CategoryResponse&gt; categoryResponses = product.getCategories() != null ?&#10;                product.getCategories().stream()&#10;                        .map(this::mapToCategoryResponse)&#10;                        .toList() : List.of();&#10;&#10;        // Build common ProductResponse instance&#10;        return ProductResponse.builder()&#10;                .id(product.getId())&#10;                .name(product.getName())&#10;                .description(product.getDescription())&#10;                .price(product.getPrice())&#10;                .categories(categoryResponses)&#10;                .imageUrls(product.getImageUrls())&#10;                .attributes(product.getAttributes())&#10;                .createdAt(product.getCreatedAt())&#10;                .updatedAt(product.getUpdatedAt())&#10;                .build();&#10;    }&#10;&#10;    private CategoryResponse mapToCategoryResponse(Category category) {&#10;        return CategoryResponse.builder()&#10;                .id(category.getId())&#10;                .name(category.getName())&#10;                .description(category.getDescription())&#10;                .status(category.getStatus())&#10;                .products(category.getProducts())&#10;                .createdAt(category.getCreatedAt() != null ?&#10;                        LocalDateTime.ofInstant(category.getCreatedAt(), java.time.ZoneOffset.UTC) : null)&#10;                .updatedAt(category.getUpdatedAt() != null ?&#10;                        LocalDateTime.ofInstant(category.getUpdatedAt(), java.time.ZoneOffset.UTC) : null)&#10;                .build();&#10;    }&#10;&#10;    public void createProduct(String sellerId, String roles, ProductRequest productRequest) {&#10;        log.info(&quot;Creating new product: {}&quot;, productRequest.getName());&#10;        String roleHeader = roles.toUpperCase();&#10;        List&lt;String&gt; rolesList = Arrays.stream(roleHeader.split(&quot;,&quot;))&#10;                .map(String::trim)&#10;                .toList();&#10;        log.info(&quot;User roles: {}&quot;, rolesList);&#10;        if (rolesList.stream().noneMatch(r -&gt; r.contains(&quot;ROLE_SELLER&quot;))) {&#10;            throw new InvalidProductDataException(&quot;Only users with SELLER role can create products&quot;);&#10;        }&#10;        if (productRepository.existsByName(productRequest.getName())) {&#10;            throw new DuplicateProductException(&quot;Product with name '&quot; + productRequest.getName() + &quot;' already exists&quot;);&#10;        }&#10;&#10;        List&lt;Category&gt; categories = List.of();&#10;        if (productRequest.getCategoryIds() != null &amp;&amp; !productRequest.getCategoryIds().isEmpty()) {&#10;            categories = categoryRepository.findAllById(productRequest.getCategoryIds());&#10;&#10;            // Validate that all categories exist&#10;            if (categories.size() != productRequest.getCategoryIds().size()) {&#10;                throw new CategoryNotFoundException(&quot;One or more category IDs not found&quot;);&#10;            }&#10;        }&#10;&#10;        Product product = new Product();&#10;        product.setName(productRequest.getName());&#10;        product.setDescription(productRequest.getDescription());&#10;        product.setPrice(productRequest.getPrice());&#10;        product.setCategories(categories);&#10;        product.setImageUrls(productRequest.getImageUrls());&#10;        product.setAttributes(productRequest.getAttributes());&#10;        Product savedProduct = productRepository.save(product);&#10;        log.info(&quot;Product created successfully with ID: {}&quot;, savedProduct.getId());&#10;        ProductCreatedEvent productCreatedEvent = new ProductCreatedEvent();&#10;        productCreatedEvent.setProductId(savedProduct.getId());&#10;        productCreatedEvent.setName(savedProduct.getName());&#10;        productCreatedEvent.setDescription(savedProduct.getDescription());&#10;        productCreatedEvent.setSellerId(sellerId);&#10;        productCreatedEvent.setQuantity(productRequest.getStock());&#10;        eventPublisher.publishEvent(&quot;PRODUCT_CREATED_EVENT&quot;, savedProduct.getId(), productCreatedEvent);&#10;    }&#10;&#10;    public void updateProduct(String id, ProductRequest productRequest) {&#10;        log.info(&quot;Updating product with ID: {}&quot;, id);&#10;&#10;        Product existingProduct = productRepository.findById(id)&#10;                .orElseThrow(() -&gt; new ProductNotFoundException(&quot;Product with ID &quot; + id + &quot; not found&quot;));&#10;&#10;        // Check for duplicate name (excluding current product)&#10;        Optional&lt;Product&gt; duplicateProduct = productRepository.findByName(productRequest.getName());&#10;        if (duplicateProduct.isPresent() &amp;&amp; !duplicateProduct.get().getId().equals(id)) {&#10;            throw new DuplicateProductException(&quot;Product with name '&quot; + productRequest.getName() + &quot;' already exists&quot;);&#10;        }&#10;&#10;        // Convert category IDs to Category objects&#10;        List&lt;Category&gt; categories = List.of();&#10;        if (productRequest.getCategoryIds() != null &amp;&amp; !productRequest.getCategoryIds().isEmpty()) {&#10;            categories = categoryRepository.findAllById(productRequest.getCategoryIds());&#10;&#10;            // Validate that all categories exist&#10;            if (categories.size() != productRequest.getCategoryIds().size()) {&#10;                throw new CategoryNotFoundException(&quot;One or more category IDs not found&quot;);&#10;            }&#10;        }&#10;&#10;        existingProduct.setName(productRequest.getName());&#10;        existingProduct.setDescription(productRequest.getDescription());&#10;        existingProduct.setPrice(productRequest.getPrice());&#10;        existingProduct.setCategories(categories);  // Set Category objects instead of IDs&#10;        existingProduct.setImageUrls(productRequest.getImageUrls());&#10;        existingProduct.setAttributes(productRequest.getAttributes());&#10;&#10;        productRepository.save(existingProduct);&#10;        log.info(&quot;Product updated successfully: {}&quot;, existingProduct.getName());&#10;    }&#10;&#10;    public void deleteProduct(String id) {&#10;        log.info(&quot;Deleting product with ID: {}&quot;, id);&#10;&#10;        Product product = productRepository.findById(id)&#10;                .orElseThrow(() -&gt; new ProductNotFoundException(&quot;Product with ID &quot; + id + &quot; not found&quot;));&#10;&#10;        productRepository.delete(product);&#10;        log.info(&quot;Product deleted successfully: {}&quot;, product.getName());&#10;    }&#10;&#10;&#10;    public List&lt;Product&gt; findProductsByIdsAndSellerId(List&lt;String&gt; ids) {&#10;        log.info(&quot;Finding products by IDs for seller ID: {}&quot;, ids);&#10;        List&lt;Product&gt; productList = productRepository.findAllByIdIn(ids);&#10;        if (productList.isEmpty()) {&#10;            log.warn(&quot;No products found for the given IDs: {}&quot;, ids);&#10;        } else {&#10;            log.info(&quot;Found {} products for the given IDs&quot;, productList.size());&#10;        }&#10;        return productList;&#10;    }&#10;&#10;    public HomePageResponse getHomePageProducts(){&#10;        log.info(&quot;Fetching homepage products asynchronously...&quot;);&#10;        long startTime = System.currentTimeMillis();&#10;        int FEATURED_LIMIT = 8;&#10;        int NEW_ARRIVALS_LIMIT = 8;&#10;        int MOST_LIKED_LIMIT = 8;&#10;        CompletableFuture&lt;List&lt;Product&gt;&gt; featuredFuture = CompletableFuture.supplyAsync(()-&gt;productRepository&#10;                .findByIsFeaturedTrue(PageRequest.of(0, FEATURED_LIMIT)));&#10;        CompletableFuture&lt;List&lt;Product&gt;&gt; newArrialFuture=CompletableFuture.supplyAsync(()-&gt;productRepository&#10;                .findByIsAvailableTrue(PageRequest.of(0, NEW_ARRIVALS_LIMIT)));&#10;        CompletableFuture&lt;List&lt;Product&gt;&gt; mostLikedFuture=CompletableFuture.supplyAsync(()-&gt;productRepository&#10;                .findByIsAvailableTrueOrderByAverageRatingDesc(PageRequest.of(0, MOST_LIKED_LIMIT)));&#10;        CompletableFuture.allOf(featuredFuture,newArrialFuture,mostLikedFuture).join();&#10;        try{&#10;            List&lt;ProductResponse&gt; featuredProducts = mapToCardDto(featuredFuture.get());&#10;            List&lt;ProductResponse&gt; newArrivalsProducts = mapToCardDto(newArrialFuture.get());&#10;            List&lt;ProductResponse&gt; mostLikedProducts = mapToCardDto(mostLikedFuture.get());&#10;            long endTime = System.currentTimeMillis();&#10;            log.info(&quot;Fetched homepage products in {} ms&quot;, (endTime - startTime));&#10;            return HomePageResponse.builder()&#10;                    .featuredProducts(featuredProducts)&#10;                    .newArrivals(newArrivalsProducts)&#10;                    .bestSellers(mostLikedProducts)&#10;                    .build();&#10;        } catch(Exception e){&#10;            log.error(&quot;Error fetching homepage products: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Failed to fetch homepage products&quot;, e);&#10;        }&#10;    }&#10;&#10;    private List&lt;ProductResponse&gt; mapToCardDto(List&lt;Product&gt; products) {&#10;        if (products == null || products.isEmpty()) {&#10;            return Collections.emptyList();&#10;        }&#10;&#10;        return products.stream().map(product -&gt; ProductResponse.builder()&#10;                 .id(product.getId())&#10;                 .name(product.getName())&#10;                 .slug(product.getSlug())&#10;                 .price(product.getPrice())&#10;                 .salePrice(product.getSalePrice())&#10;                 .averageRating(product.getAverageRating())&#10;                 .ratingCount(product.getRatingCount())&#10;                 .attributes(product.getAttributes())&#10;                 .imageUrls(product.getImageUrls())&#10;                 .createdAt(product.getCreatedAt())&#10;                 .description(product.getDescription())&#10;                 .isAvailable(product.isAvailable())&#10;                 .isFeatured(product.isFeatured())&#10;                 .primaryCategoryName(product.getPrimaryCategoryName())&#10;                 .sellerId(product.getSellerId())&#10;                 .updatedAt(product.getUpdatedAt())&#10;                 .build()).toList();&#10;    }&#10;&#10;    public List&lt;ProductResponse&gt; getAllProducts(Integer page, Integer size) {&#10;        int pageNumber = page != null &amp;&amp; page &gt;= 0 ? page : 0;&#10;        int pageSize = size != null &amp;&amp; size &gt; 0 ? size : 20;&#10;&#10;        var pageable = PageRequest.of(pageNumber, pageSize);&#10;        log.info(&quot;Fetching products page={} size={}&quot;, pageNumber, pageSize);&#10;&#10;        List&lt;Product&gt; products = productRepository.findAll(pageable).getContent();&#10;&#10;        return products.stream()&#10;                .map(this::mapToProductResponse)&#10;                .toList();&#10;    }&#10;&#10;    public List&lt;ProductResponse&gt; getAllProducts(Integer page, Integer size, String keyword, String categorySlug,&#10;                                               Double minPrice, Double maxPrice) {&#10;        int pageNumber = page != null &amp;&amp; page &gt;= 0 ? page : 0;&#10;        int pageSize = size != null &amp;&amp; size &gt; 0 ? size : 20;&#10;&#10;        var pageable = PageRequest.of(pageNumber, pageSize);&#10;        log.info(&quot;Fetching products with filters page={} size={} keyword={} categorySlug={} minPrice={} maxPrice={}&quot;,&#10;                pageNumber, pageSize, keyword, categorySlug, minPrice, maxPrice);&#10;&#10;        // For now, apply filters in memory to keep it simple with MongoRepository.&#10;        // In future we can replace with custom MongoTemplate queries.&#10;        List&lt;Product&gt; products = productRepository.findAll(pageable).getContent();&#10;&#10;        return products.stream()&#10;                .filter(p -&gt; {&#10;                    if (keyword != null &amp;&amp; !keyword.isBlank()) {&#10;                        String kw = keyword.toLowerCase();&#10;                        boolean matchName = p.getName() != null &amp;&amp; p.getName().toLowerCase().contains(kw);&#10;                        boolean matchDesc = p.getDescription() != null &amp;&amp; p.getDescription().toLowerCase().contains(kw);&#10;                        if (!matchName &amp;&amp; !matchDesc) return false;&#10;                    }&#10;                    if (categorySlug != null &amp;&amp; !categorySlug.isBlank()) {&#10;                        if (p.getPrimaryCategoryName() == null ||&#10;                                !p.getPrimaryCategoryName().equalsIgnoreCase(categorySlug)) {&#10;                            return false;&#10;                        }&#10;                    }&#10;                    if (minPrice != null &amp;&amp; p.getPrice() &lt; minPrice) return false;&#10;                    if (maxPrice != null &amp;&amp; p.getPrice() &gt; maxPrice) return false;&#10;                    return true;&#10;                })&#10;                .map(this::mapToProductResponse)&#10;                .toList();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.em.productservice.Service;&#10;&#10;import com.em.commonevent.ProductCreatedEvent;&#10;import com.em.productservice.Model.Category;&#10;import com.em.productservice.Model.Product;&#10;import com.em.productservice.Repository.CategoryRepository;&#10;import com.em.productservice.Repository.ProductRepository;&#10;import com.em.productservice.dto.request.ProductRequest;&#10;import com.em.common.dto.product.CategoryResponse;&#10;import com.em.productservice.dto.response.HomePageResponse;&#10;import com.em.common.dto.product.ProductResponse;&#10;import com.em.productservice.events.EventPublisherService;&#10;import com.em.productservice.exception.CategoryNotFoundException;&#10;import com.em.productservice.exception.DuplicateProductException;&#10;import com.em.productservice.exception.InvalidProductDataException;&#10;import com.em.productservice.exception.ProductNotFoundException;&#10;import lombok.AllArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.Arrays;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.concurrent.CompletableFuture;&#10;&#10;@Service&#10;@AllArgsConstructor&#10;@Slf4j&#10;public class ProductService {&#10;&#10;    private final ProductRepository productRepository;&#10;    private final CategoryRepository categoryRepository;&#10;    private final EventPublisherService eventPublisher;&#10;&#10;    public List&lt;ProductResponse&gt; getAllProducts() {&#10;        log.info(&quot;Fetching all products from database...&quot;);&#10;        List&lt;Product&gt; products = productRepository.findAll();&#10;        log.info(&quot;Found {} products in database&quot;, products.size());&#10;&#10;        List&lt;ProductResponse&gt; productResponses = products.stream()&#10;                .map(this::mapToProductResponse)&#10;                .toList();&#10;        log.info(&quot;Mapped {} products to response DTOs&quot;, productResponses.size());&#10;&#10;        return productResponses;&#10;    }&#10;&#10;    public ProductResponse getProductById(String id) {&#10;        log.info(&quot;Fetching product with ID: {}&quot;, id);&#10;        Product product = productRepository.findById(id)&#10;                .orElseThrow(() -&gt; new ProductNotFoundException(&quot;Product with ID &quot; + id + &quot; not found&quot;));&#10;&#10;        log.info(&quot;Found product: {}&quot;, product.getName());&#10;        return mapToProductResponse(product);&#10;    }&#10;&#10;    private ProductResponse mapToProductResponse(Product product) {&#10;        // Convert Category objects to common CategoryResponse DTOs&#10;        List&lt;CategoryResponse&gt; categoryResponses = product.getCategories() != null ?&#10;                product.getCategories().stream()&#10;                        .map(this::mapToCategoryResponse)&#10;                        .toList() : List.of();&#10;&#10;        // Build common ProductResponse instance&#10;        return ProductResponse.builder()&#10;                .id(product.getId())&#10;                .name(product.getName())&#10;                .description(product.getDescription())&#10;                .price(product.getPrice())&#10;                .categories(categoryResponses)&#10;                .imageUrls(product.getImageUrls())&#10;                .attributes(product.getAttributes())&#10;                .createdAt(product.getCreatedAt())&#10;                .updatedAt(product.getUpdatedAt())&#10;                .build();&#10;    }&#10;&#10;    private CategoryResponse mapToCategoryResponse(Category category) {&#10;        return CategoryResponse.builder()&#10;                .id(category.getId())&#10;                .name(category.getName())&#10;                .description(category.getDescription())&#10;                .status(category.getStatus())&#10;                .products(category.getProducts())&#10;                .createdAt(category.getCreatedAt() != null ?&#10;                        LocalDateTime.ofInstant(category.getCreatedAt(), java.time.ZoneOffset.UTC) : null)&#10;                .updatedAt(category.getUpdatedAt() != null ?&#10;                        LocalDateTime.ofInstant(category.getUpdatedAt(), java.time.ZoneOffset.UTC) : null)&#10;                .build();&#10;    }&#10;&#10;    public void createProduct(String sellerId, String roles, ProductRequest productRequest) {&#10;        log.info(&quot;Creating new product: {}&quot;, productRequest.getName());&#10;        String roleHeader = roles.toUpperCase();&#10;        List&lt;String&gt; rolesList = Arrays.stream(roleHeader.split(&quot;,&quot;))&#10;                .map(String::trim)&#10;                .toList();&#10;        log.info(&quot;User roles: {}&quot;, rolesList);&#10;        if (rolesList.stream().noneMatch(r -&gt; r.contains(&quot;ROLE_SELLER&quot;))) {&#10;            throw new InvalidProductDataException(&quot;Only users with SELLER role can create products&quot;);&#10;        }&#10;        if (productRepository.existsByName(productRequest.getName())) {&#10;            throw new DuplicateProductException(&quot;Product with name '&quot; + productRequest.getName() + &quot;' already exists&quot;);&#10;        }&#10;&#10;        List&lt;Category&gt; categories = List.of();&#10;        if (productRequest.getCategoryIds() != null &amp;&amp; !productRequest.getCategoryIds().isEmpty()) {&#10;            categories = categoryRepository.findAllById(productRequest.getCategoryIds());&#10;&#10;            // Validate that all categories exist&#10;            if (categories.size() != productRequest.getCategoryIds().size()) {&#10;                throw new CategoryNotFoundException(&quot;One or more category IDs not found&quot;);&#10;            }&#10;        }&#10;&#10;        Product product = new Product();&#10;        product.setName(productRequest.getName());&#10;        product.setDescription(productRequest.getDescription());&#10;        product.setPrice(productRequest.getPrice());&#10;        product.setCategories(categories);&#10;        product.setImageUrls(productRequest.getImageUrls());&#10;        product.setAttributes(productRequest.getAttributes());&#10;        Product savedProduct = productRepository.save(product);&#10;        log.info(&quot;Product created successfully with ID: {}&quot;, savedProduct.getId());&#10;        ProductCreatedEvent productCreatedEvent = new ProductCreatedEvent();&#10;        productCreatedEvent.setProductId(savedProduct.getId());&#10;        productCreatedEvent.setName(savedProduct.getName());&#10;        productCreatedEvent.setDescription(savedProduct.getDescription());&#10;        productCreatedEvent.setSellerId(sellerId);&#10;        productCreatedEvent.setQuantity(productRequest.getStock());&#10;        eventPublisher.publishEvent(&quot;PRODUCT_CREATED_EVENT&quot;, savedProduct.getId(), productCreatedEvent);&#10;    }&#10;&#10;    public void updateProduct(String id, ProductRequest productRequest) {&#10;        log.info(&quot;Updating product with ID: {}&quot;, id);&#10;&#10;        Product existingProduct = productRepository.findById(id)&#10;                .orElseThrow(() -&gt; new ProductNotFoundException(&quot;Product with ID &quot; + id + &quot; not found&quot;));&#10;&#10;        // Check for duplicate name (excluding current product)&#10;        Optional&lt;Product&gt; duplicateProduct = productRepository.findByName(productRequest.getName());&#10;        if (duplicateProduct.isPresent() &amp;&amp; !duplicateProduct.get().getId().equals(id)) {&#10;            throw new DuplicateProductException(&quot;Product with name '&quot; + productRequest.getName() + &quot;' already exists&quot;);&#10;        }&#10;&#10;        // Convert category IDs to Category objects&#10;        List&lt;Category&gt; categories = List.of();&#10;        if (productRequest.getCategoryIds() != null &amp;&amp; !productRequest.getCategoryIds().isEmpty()) {&#10;            categories = categoryRepository.findAllById(productRequest.getCategoryIds());&#10;&#10;            // Validate that all categories exist&#10;            if (categories.size() != productRequest.getCategoryIds().size()) {&#10;                throw new CategoryNotFoundException(&quot;One or more category IDs not found&quot;);&#10;            }&#10;        }&#10;&#10;        existingProduct.setName(productRequest.getName());&#10;        existingProduct.setDescription(productRequest.getDescription());&#10;        existingProduct.setPrice(productRequest.getPrice());&#10;        existingProduct.setCategories(categories);  // Set Category objects instead of IDs&#10;        existingProduct.setImageUrls(productRequest.getImageUrls());&#10;        existingProduct.setAttributes(productRequest.getAttributes());&#10;&#10;        productRepository.save(existingProduct);&#10;        log.info(&quot;Product updated successfully: {}&quot;, existingProduct.getName());&#10;    }&#10;&#10;    public void deleteProduct(String id) {&#10;        log.info(&quot;Deleting product with ID: {}&quot;, id);&#10;&#10;        Product product = productRepository.findById(id)&#10;                .orElseThrow(() -&gt; new ProductNotFoundException(&quot;Product with ID &quot; + id + &quot; not found&quot;));&#10;&#10;        productRepository.delete(product);&#10;        log.info(&quot;Product deleted successfully: {}&quot;, product.getName());&#10;    }&#10;&#10;&#10;    public List&lt;Product&gt; findProductsByIdsAndSellerId(List&lt;String&gt; ids) {&#10;        log.info(&quot;Finding products by IDs for seller ID: {}&quot;, ids);&#10;        List&lt;Product&gt; productList = productRepository.findAllByIdIn(ids);&#10;        if (productList.isEmpty()) {&#10;            log.warn(&quot;No products found for the given IDs: {}&quot;, ids);&#10;        } else {&#10;            log.info(&quot;Found {} products for the given IDs&quot;, productList.size());&#10;        }&#10;        return productList;&#10;    }&#10;&#10;    public HomePageResponse getHomePageProducts(){&#10;        log.info(&quot;Fetching homepage products asynchronously...&quot;);&#10;        long startTime = System.currentTimeMillis();&#10;        int FEATURED_LIMIT = 8;&#10;        int NEW_ARRIVALS_LIMIT = 8;&#10;        int MOST_LIKED_LIMIT = 8;&#10;        CompletableFuture&lt;List&lt;Product&gt;&gt; featuredFuture = CompletableFuture.supplyAsync(()-&gt;productRepository&#10;                .findByIsFeaturedTrue(PageRequest.of(0, FEATURED_LIMIT)));&#10;        CompletableFuture&lt;List&lt;Product&gt;&gt; newArrialFuture=CompletableFuture.supplyAsync(()-&gt;productRepository&#10;                .findByIsAvailableTrue(PageRequest.of(0, NEW_ARRIVALS_LIMIT)));&#10;        CompletableFuture&lt;List&lt;Product&gt;&gt; mostLikedFuture=CompletableFuture.supplyAsync(()-&gt;productRepository&#10;                .findByIsAvailableTrueOrderByAverageRatingDesc(PageRequest.of(0, MOST_LIKED_LIMIT)));&#10;        CompletableFuture.allOf(featuredFuture,newArrialFuture,mostLikedFuture).join();&#10;        try{&#10;            List&lt;ProductResponse&gt; featuredProducts = mapToCardDto(featuredFuture.get());&#10;            List&lt;ProductResponse&gt; newArrivalsProducts = mapToCardDto(newArrialFuture.get());&#10;            List&lt;ProductResponse&gt; mostLikedProducts = mapToCardDto(mostLikedFuture.get());&#10;            long endTime = System.currentTimeMillis();&#10;            log.info(&quot;Fetched homepage products in {} ms&quot;, (endTime - startTime));&#10;            return HomePageResponse.builder()&#10;                    .featuredProducts(featuredProducts)&#10;                    .newArrivals(newArrivalsProducts)&#10;                    .bestSellers(mostLikedProducts)&#10;                    .build();&#10;        } catch(Exception e){&#10;            log.error(&quot;Error fetching homepage products: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Failed to fetch homepage products&quot;, e);&#10;        }&#10;    }&#10;&#10;    private List&lt;ProductResponse&gt; mapToCardDto(List&lt;Product&gt; products) {&#10;        if (products == null || products.isEmpty()) {&#10;            return Collections.emptyList();&#10;        }&#10;&#10;        return products.stream().map(product -&gt; ProductResponse.builder()&#10;                 .id(product.getId())&#10;                 .name(product.getName())&#10;                 .slug(product.getSlug())&#10;                 .price(product.getPrice())&#10;                 .salePrice(product.getSalePrice())&#10;                 .averageRating(product.getAverageRating())&#10;                 .ratingCount(product.getRatingCount())&#10;                 .attributes(product.getAttributes())&#10;                 .imageUrls(product.getImageUrls())&#10;                 .createdAt(product.getCreatedAt())&#10;                 .description(product.getDescription())&#10;                 .isAvailable(product.isAvailable())&#10;                 .isFeatured(product.isFeatured())&#10;                 .primaryCategoryName(product.getPrimaryCategoryName())&#10;                 .sellerId(product.getSellerId())&#10;                 .updatedAt(product.getUpdatedAt())&#10;                 .build()).toList();&#10;    }&#10;&#10;    public List&lt;ProductResponse&gt; getAllProducts(Integer page, Integer size) {&#10;        int pageNumber = page != null &amp;&amp; page &gt;= 0 ? page : 0;&#10;        int pageSize = size != null &amp;&amp; size &gt; 0 ? size : 20;&#10;&#10;        var pageable = PageRequest.of(pageNumber, pageSize);&#10;        log.info(&quot;Fetching products page={} size={}&quot;, pageNumber, pageSize);&#10;&#10;        List&lt;Product&gt; products = productRepository.findAll(pageable).getContent();&#10;&#10;        return products.stream()&#10;                .map(this::mapToProductResponse)&#10;                .toList();&#10;    }&#10;&#10;    public List&lt;ProductResponse&gt; getAllProducts(Integer page, Integer size, String keyword, String categorySlug,&#10;                                               Double minPrice, Double maxPrice) {&#10;        int pageNumber = page != null &amp;&amp; page &gt;= 0 ? page : 0;&#10;        int pageSize = size != null &amp;&amp; size &gt; 0 ? size : 20;&#10;&#10;        double effectiveMin = minPrice != null ? minPrice : 0d;&#10;        double effectiveMax = maxPrice != null ? maxPrice : Double.MAX_VALUE;&#10;&#10;        var pageable = PageRequest.of(pageNumber, pageSize);&#10;        log.info(&quot;Fetching products with filters page={} size={} keyword={} categorySlug={} minPrice={} maxPrice={}&quot;,&#10;                pageNumber, pageSize, keyword, categorySlug, effectiveMin, effectiveMax);&#10;&#10;        // Server-side filtering with Mongo query methods for category + price,&#10;        // then apply keyword filter in memory (on the page) for simplicity.&#10;        Page&lt;Product&gt; pageResult;&#10;        boolean hasCategory = categorySlug != null &amp;&amp; !categorySlug.isBlank();&#10;        boolean hasPriceRange = minPrice != null || maxPrice != null;&#10;&#10;        if (hasCategory &amp;&amp; hasPriceRange) {&#10;            pageResult = productRepository.findByPrimaryCategoryNameIgnoreCaseAndPriceBetween(&#10;                    categorySlug,&#10;                    effectiveMin,&#10;                    effectiveMax,&#10;                    pageable&#10;            );&#10;        } else if (hasCategory) {&#10;            pageResult = productRepository.findByPrimaryCategoryNameIgnoreCase(categorySlug, pageable);&#10;        } else if (hasPriceRange) {&#10;            pageResult = productRepository.findByPriceBetween(effectiveMin, effectiveMax, pageable);&#10;        } else {&#10;            pageResult = productRepository.findAll(pageable);&#10;        }&#10;&#10;        List&lt;Product&gt; products = pageResult.getContent();&#10;&#10;        return products.stream()&#10;                .filter(p -&gt; {&#10;                    if (keyword != null &amp;&amp; !keyword.isBlank()) {&#10;                        String kw = keyword.toLowerCase();&#10;                        boolean matchName = p.getName() != null &amp;&amp; p.getName().toLowerCase().contains(kw);&#10;                        boolean matchDesc = p.getDescription() != null &amp;&amp; p.getDescription().toLowerCase().contains(kw);&#10;                        return matchName || matchDesc;&#10;                    }&#10;                    return true;&#10;                })&#10;                .map(this::mapToProductResponse)&#10;                .toList();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>